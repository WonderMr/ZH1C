Функция Запиши(Событие, МалоеОписание, БольшоеОписание = "", Уровень = Неопределено) Экспорт
    Если
        НЕ ЗначениеЗаполнено(Уровень)
    Тогда
        Уровень             =   EventLogLevel.Information;
    КонецЕсли;
    ДТ                      =   Формат(ТекущаяДатаСеанса(), "ДЛФ = ДВ");
    МалоеОписание           =   ДТ + " " + МалоеОписание;
    ЗаписьЖурналаРегистрации(Событие, Уровень, , МалоеОписание, БольшоеОписание);
    Если
        Уровень = EventLogLevel.Error
    Тогда
        Сообщить(БольшоеОписание);
    Иначе
        Сообщить(МалоеОписание);
    КонецЕсли;
    Возврат МалоеОписание;
КонецФункции

Функция ЗапишиОшибку(ИнформацияОбОшибке, Событие = "Ошибка", МалоеОписание = "", БольшоеОписание = "", Уровень) Экспорт
    СимВКПС                 =   Символы.ВК + Символы.ПС;
    Если
        Не ЗначениеЗаполнено(Уровень)
    Тогда
        Уровень             =   EventLogLevel.Error;
    КонецЕсли;
    Если
        ЗначениеЗаполнено(МалоеОписание)
    Тогда
        МалоеОписание       =   ИнформацияОбОшибке.Описание + " " + МалоеОписание;
    Иначе
        МалоеОписание       =   ИнформацияОбОшибке.Описание;
    КонецЕсли;
    ЕстьПричина             =   ЕстьСвойство        (ИнформацияОбОшибке, "Причина")
                            И   Не ИнформацияОбОшибке.Причина = Неопределено
                            И   ЕстьСвойство        (ИнформацияОбОшибке.Причина, "Описание")
                            И   ЗначениеЗаполнено   (ИнформацияОбОшибке.Причина.Описание);
    код                     =   Ж_ext.СвернутьВ1Пробел(ИнформацияОбОшибке.ИсходнаяСтрока);
    Причина                 =   ?(ЕстьПричина,  ИнформацияОбОшибке.Причина.Описание, "");
    НомСтр                  =   Строка(ИнформацияОбОшибке.НомерСтроки);
    ErrTxt                  =   БольшоеОписание      + " "
                            +   "Описание        = " + ИнформацияОбОшибке.Описание  + СимВКПС
                            +   "Номер строки    = " + НомСтр                       + СимВКПС
                            +   "Причина         = " + Причина                      + СимВКПС
                            +   "Имя модуля      = " + ИнформацияОбОшибке.ИмяМодуля + СимВКПС
                            +   "Исходная строка = " + код                          + СимВКПС;
    Если
        ЗначениеЗаполнено(БольшоеОписание)
    Тогда
        БольшоеОписание     =   ErrTxt + СимВКПС + БольшоеОписание;
    Иначе
        БольшоеОписание     =   ErrTxt;
    КонецЕсли;
    Возврат Запиши(Событие, МалоеОписание, БольшоеОписание, EventLogLevel.Error);
КонецФункции

Функция ПричесатьДату(ЭтаДата, Язык = "") Экспорт
    Если
        НЕ ЗначениеЗаполнено(ЭтаДата)
    ИЛИ ЭтаДата = Null
    Тогда
        ЭтаДата                 =   ТекущаяДата();
    КонецЕсли;
    Если
        ТипЗнч(ЭтаДата) = Тип("Строка")
    Тогда
        ЭтаДата             =   Дата(ЭтаДата);
    КонецЕсли;
    Если
        ЗначениеЗаполнено(Язык)
    Тогда
        DDate                   =   Формат(ЭтаДата, "ДЛФ = ДД; Л = " + Язык);
        DDate                   =   СокрЛП(DDate);
    Иначе
        DDate                   =   Формат(ЭтаДата, "ДЛФ = ДД");
        DDate                   =   СокрЛП(DDate);
        DDate                   =   ?(День(ЭтаДата) < 10, "0" + DDate, DDate);
    КонецЕсли;
    Возврат DDate;
КонецФункции

Функция ЕстьСвойство(пОбъект, пИмяРек, пТипЗначения = Неопределено) Экспорт
    КонтрольноеЗначение     =   Новый УникальныйИдентификатор;
    Попытка
        СтруктураРеквизита  =   Новый Структура(пИмяРек, КонтрольноеЗначение);
    Исключение
        Возврат Ложь;
    КонецПопытки;
    Если
        СтруктураРеквизита.Количество() > 1
    Тогда
        Возврат Ложь; // если передан список реквизитов, то создастся структура со списком ключей, что сигнатурой метода не предусмотрено
    КонецЕсли;
    ПроверятьТип            =   ТипЗНЧ(пТипЗначения) = Тип("Тип");
    Попытка
        ЗаполнитьЗначенияСвойств(СтруктураРеквизита, пОбъект);
    Исключение
        Возврат Ложь
    КонецПопытки;
    Результат               =   Ложь;
    Значение                =   СтруктураРеквизита[пИмяРек];
    Если
        Значение <> КонтрольноеЗначение
    Тогда
        Если
            ПроверятьТип
        Тогда
            Результат       =   пТипЗначения = ТипЗНЧ(Значение);
        Иначе
            Результат       =   Истина;
        КонецЕсли;
    Иначе
        Результат           =   Ложь;
    КонецЕсли;
    Возврат Результат;
КонецФункции

Функция СвернутьВ1Пробел(ВхСтрока) Экспорт
    Рез                     =   "";
    Берём                   =   Ложь;
    LastSpace               =   Истина;
    ПредСимв                =   "";
    Игнор                   =   ".()";
    Для СтрЭлемН = 0
    По  СтрДлина(ВхСтрока)
    Цикл
        Сим                 =   Сред(ВхСтрока ,СтрЭлемН, 1);
        Если
            Сим = Символы.ВК
        Или Сим = Символы.ВТаб
        Или Сим = Символы.НПП
        Или Сим = Символы.ПС
        Или Сим = Символы.ПФ
        Или Сим = Символы.Таб
        Тогда
            Продолжить;
        КонецЕсли;
        Если
            Сим = " "
        Тогда
            Если
                LastSpace
            Тогда
                Продолжить;
            ИначеЕсли
                СтрНайти(Игнор, ПредСимв) > 0
            Тогда
                Берём       =   Ложь;
                LastSpace   =   Ложь;
                Продолжить;
            Иначе
                Берём       =   Истина;
                LastSpace   =   Истина;
            КонецЕсли;
        Иначе
            Берём           =   Истина;
            LastSpace       =   Ложь;
        КонецЕсли;
        Если
            Берём
        Тогда
            Рез             =   Рез + Сим;
            ПредСимв        =   Сим;
        КонецЕсли;
    КонецЦикла;
    Возврат Рез;
КонецФункции

Функция ПолучитьДопРеквизит(ЭтотОбъект, ИмяРеквизита, Текстом = Истина) Экспорт
    Попытка
        Если
            Не ЕстьСвойство(ЭтотОбъект, "ДополнительныеРеквизиты")
        Или Не ЭтотОбъект.ДополнительныеРеквизиты.Количество() > 0
        Тогда
            Возврат "";
        КонецЕсли;
        Для Каждого Реквизит
        Из          ЭтотОбъект.ДополнительныеРеквизиты
        Цикл
            Если
                Реквизит.Свойство.Заголовок = ИмяРеквизита
            Тогда
                Если
                    Ж_ext.ЕстьСвойство(Реквизит.Значение, "ПолноеНаименование")
                И   Текстом
                Тогда
                    Если
                        ЗначениеЗаполнено(Реквизит.Значение.ПолноеНаименование)
                    Тогда
                        Возврат Реквизит.Значение.ПолноеНаименование;
                    Иначе
                        Возврат Реквизит.Значение.Наименование;
                    КонецЕсли;
                Иначе
                    Возврат Реквизит.Значение;
                КонецЕсли
            КонецЕсли
        КонецЦикла;
    Исключение
        Инфа                =   ИнформацияОбОшибке();
        Ж_ext.ЗапишиОшибку(Инфа, "Ж_ext:СохранитьДопРеквизит");
    КонецПопытки;
    Возврат "";
КонецФункции

Процедура СохранитьДопРеквизит(МойОбъект, ИмяРеквизита, ЗначениеРеквизита) Экспорт
    Обработки.Ж_ДопРеквизиты.СохранитьДопРеквизит(МойОбъект, ИмяРеквизита, ЗначениеРеквизита);
КонецПроцедуры

Функция ПолучитьСвойствоРеквизита(МоёИмя, МойОбъект) Экспорт
    Возврат Обработки.Ж_ДопРеквизиты.ПолучитьСвойствоРеквизита(МоёИмя, МойОбъект);
КонецФункции

Функция ПолучитьСписокЗначенийДопРеквизита(ЗначениеОбъекта, НазваниеРеквизита) Экспорт
    Возврат Обработки.Ж_ДопРеквизиты.ПолучитьСписокЗначенийДопРеквизита(ЗначениеОбъекта, НазваниеРеквизита)
КонецФункции

Функция ЯвляетсяКириллическойБуквой(Символ) Экспорт
    // Проверяем, что строка не пустая и состоит из одного символа
    Если ПустаяСтрока(Символ) Или СтрДлина(Символ) <> 1 Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Получаем Unicode-код символа
    КодСимвола = КодСимвола(Символ, 1);
    
    // Проверка на базовый блок Кириллицы (U+0400 – U+04FF)
    Если
        (КодСимвола >= 1024)
    И   (КодСимвола <= 1279)
    Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Проверка на Кириллица Дополнение (U+0500 – U+052F)
    Если
        (КодСимвола >= 1280)
    И   (КодСимвола <= 1327)
    Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Проверка на Кириллица Дополнение-А (U+2DE0 – U+2DFF)
    Если
        (КодСимвола >= 11744)
    И   (КодСимвола <= 11775)
    Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Проверка на Кириллица Дополнение-Б (U+A640 – U+A69F)
    Если
        (КодСимвола >= 42688)
    И   (КодСимвола <= 42751)
    Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Проверка на Кириллица Дополнение-С (U+1C80 – U+1C8F)
    Если
        (КодСимвола >= 7296)
    И   (КодСимвола <= 7311)
    Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Если символ не попадает ни в один из диапазонов
    Возврат Ложь;
КонецФункции

Функция НайтиПозицииЗаглавныхСлов(МояСтрока, ТолькоКириллица = Ложь) Экспорт
    Вернём                  =   Новый Массив();
    Для i = 1
    По  СтрДлина(МояСтрока)
    Цикл
        Символ              =   Сред(МояСтрока, i, 1);
        ПредСимвол          =   ?(i = 1, " ", Сред(МояСтрока, i - 1, 1));
        ВерхнийСимвол       =   ВРег(Символ);
        Если
            КодСимвола(Символ) = КодСимвола(ВерхнийСимвол)
        И   ПредСимвол         = " "
        Тогда
            Если
                ТолькоКириллица
            Тогда
                Если
                    ЯвляетсяКириллическойБуквой(Символ)
                Тогда
                    Вернём.Добавить(i);
                КонецЕсли;
            Иначе
                Вернём.Добавить(i);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат Вернём;
КонецФункции
//Процедура Ожидание(Длительность) Экспорт
//     Идентификатор          =   Новый УникальныйИдентификатор;
//     НачатьТранзакцию();
//     Блокировка             =   Новый БлокировкаДанных; 
//     Элемент                =   Блокировка.Добавить("РегистрСведений.Ж_Ожидание");
//     Элемент.Режим          =   РежимБлокировкиДанных.Исключительный;
//     Элемент.УстановитьЗначение("Идентификатор", Идентификатор);
//     Блокировка.Заблокировать();
//     мсвПараметров          =   Новый Массив;
//     мсвПараметров.Добавить(Идентификатор);
//     Задание                =   ФоновыеЗадания.Выполнить("Ж_ext.ВыполнитьПаузу",
//                                                        мсвПараметров,
//                                                        ,
//                                                        "Выполнить паузу " + Длительность + " сек.");
//     Попытка
//          Задание.ОжидатьЗавершения(Длительность);
//          Исключение
//     КонецПопытки;
//     ОтменитьТранзакцию();
// КонецПроцедуры

Процедура ВыполнитьПаузу(Идентификатор) Экспорт
     НачатьТранзакцию();
     Блокировка             =   Новый БлокировкаДанных;
     Элемент                =   Блокировка.Добавить("РегистрСведений.Ж_Ожидание");
     Элемент.Режим          =   РежимБлокировкиДанных.Исключительный;
     Элемент.УстановитьЗначение("Идентификатор", Идентификатор);
     Попытка
          Блокировка.Заблокировать();
     Исключение
     КонецПопытки;
     ОтменитьТранзакцию();
КонецПроцедуры

Функция ПочиститьАдрес(Адрес) Экспорт
    Пока
        СтрНайти(Адрес, "0,") > 0
    Или СтрНайти(Адрес, ",,") > 0
    Цикл
        Адрес               =   СтрЗаменить(Адрес, "0,", "");
        Адрес               =   СтрЗаменить(Адрес, ",,", ",");
    КонецЦикла;
    Адрес                   =   СокрЛП(Адрес);
    Если
        Прав(Адрес, 1) = ","
    Тогда
        Адрес               =   Лев(Адрес, СтрДлина(Адрес) - 1);
    КонецЕсли;
    Адрес                   =   СтрЗаменить(Адрес, ", ", ",");
    Адрес                   =   СтрЗаменить(Адрес, ",", ", ");
    Возврат Адрес;
КонецФункции

Функция РазницаДатВМесяцах(Дата1, Дата2) Экспорт
     ДатаНач                =   ?(Дата1 < Дата2, Дата1, Дата2);
     ДатаКон                =   ?(Дата1 < Дата2, Дата2, Дата1);
     Годы                   =   Год( датаКон ) - Год( датаНач );
     Месяцы                 =   Месяц( датаКон ) - Месяц( датаНач );
     Разность               =   месяцы + годы * 12;
     Возврат Разность;
 КонецФункции

Процедура СформироватьДерево(ЧтениеJSON, Дерево) Экспорт
    ИмяСвойства                                         =   Неопределено;
    Пока
        ЧтениеJSON.Прочитать()
    Цикл
        TипJSON                                         =   ЧтениеJSON.ТипТекущегоЗначения;
        Если
                        TипJSON = ТипЗначенияJSON.НачалоОбъекта
                    ИЛИ TипJSON = ТипЗначенияJSON.НачалоМассива
        Тогда
            НовыйОбъект                                 =   ?(TипJSON = ТипЗначенияJSON.НачалоОбъекта, Новый Соответствие, Новый Массив);
            Если
                 ТипЗнч(Дерево) = Тип("Массив")
            Тогда
                Дерево.Добавить(НовыйОбъект);
            ИначеЕсли
                 ТипЗнч(Дерево) = Тип("Соответствие")
            И   ЗначениеЗаполнено(ИмяСвойства)
            Тогда
                Дерево.Вставить(ИмяСвойства, НовыйОбъект);
            КонецЕсли;
            СформироватьДерево(ЧтениеJSON, НовыйОбъект);
            Если
                         Дерево = Неопределено
            Тогда
                Дерево                                  =   НовыйОбъект;
            КонецЕсли;
        ИначеЕсли
                        TипJSON = ТипЗначенияJSON.ИмяСвойства
        Тогда
            ИмяСвойства                                 =   ЧтениеJSON.ТекущееЗначение;
        ИначеЕсли
                        TипJSON = ТипЗначенияJSON.Число
                    ИЛИ TипJSON = ТипЗначенияJSON.Строка
                    ИЛИ TипJSON = ТипЗначенияJSON.Булево
                    ИЛИ TипJSON = ТипЗначенияJSON.Null
        Тогда
            Если
                 ТипЗнч(Дерево) = Тип("Массив")
            Тогда
                Дерево.Добавить(ЧтениеJSON.ТекущееЗначение);
            ИначеЕсли
                ТипЗнч(Дерево)                          =   Тип("Соответствие")
            Тогда
                Дерево.Вставить(ИмяСвойства, ЧтениеJSON.ТекущееЗначение);
            КонецЕсли;
        Иначе
            Возврат;
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

Функция JsonString2Соответствие(JsonСтрока) Экспорт
    Если
        JsonСтрока =  Null
    Тогда
        Возврат ""
    КонецЕсли;
    JsonString2СоответствиеРезультат                    =   Неопределено;
    JsonString2СоответствиеЧтениеJson                   =   Новый ЧтениеJSON();
    JsonString2СоответствиеЧтениеJson.УстановитьСтроку(JsonСтрока);
    СформироватьДерево(JsonString2СоответствиеЧтениеJson, JsonString2СоответствиеРезультат);
    Возврат JsonString2СоответствиеРезультат
КонецФункции

Функция ПолучитьЧислоИзСТроки(п_Значение) Экспорт
    Попытка
        Возврат Число(п_Значение)
    Исключение
        СтрЧисло                                =   "";
        Для I = 1
        По  СтрДлина(п_Значение)
        Цикл
            Буква                               =   Сред(п_Значение, I, 1);
            Если
                КодСимвола(Буква) >= 48
            И   КодСимвола(Буква) <= 57
            Тогда
                СтрЧисло                        =   СтрЧисло + Буква;
            КонецЕсли;
        КонецЦикла;
    КонецПопытки;
    Возврат Число(СтрЧисло)
КонецФункции

Функция ПреобразоватьПоВозможностиСтрокуВДату(СтрокаДата) Экспорт
    //Отрезаем время и дату, если есть
    ЕстьВремя           =   СтрНайти(СтрокаДата, "T");
    Если
        ЕстьВремя > 0
    Тогда
        СтрокаДата      =   Лев(СтрокаДата, ЕстьВремя - 1);
    КонецЕсли;
    // Разделяем строку на день, месяц и год
    ДатаМассив          =   СтрРазделить(СтрокаДата, "-");
    
    // Проверяем, что все части даты присутствуют
    Если
        (ДатаМассив.Количество() = 3)
    Тогда
        Год             =   Число(ДатаМассив[0]);
        Месяц           =   Число(ДатаМассив[1]);
        День            =   Число(ДатаМассив[2]);
        
        // Формируем тип Дата
        Возврат Дата(Год, Месяц, День);
    Иначе
        Возврат Неопределено;
    КонецЕсли;
КонецФункции

